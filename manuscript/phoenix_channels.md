# Phoenix Channels

*This chapter is a work in progress!*

We created our `ScoreChannel` and set up elm-phoenix-socket in the last
chapter, but we haven't really worked with Phoenix channels much outside of the
initial configuration. In this chapter, we'll take that data from our Elm
front-end game, and find a good way to handle it with our Phoenix back-end.

## Planning Out Our Approach

Our game is tracking a `playerScore` field on the Elm side as the character
collects items. And we managed to configure elm-phoenix-socket in the last
chapter, so we have the score being sent over the `ScoreChannel` as the
`payload` value. But we're still just using the default `ScoreChannel` that was
generated by Phoenix.

We'd like to sync player scores in real-time, and be able to save scores to
the database as `Gameplay` records.

In addition to our "Send Score" button below our game, we'll also add a new
"Save Score" button that allows us to save our player scores to the database.
In other words, "Send Score" will still be using for "shouting" our player
score to any other players that are connected to the socket. But the "Save
Score" button will actually create a new database record containing the
`game_id`, the `player_id`, and the `player_score`.

Then, we can work towards displaying recent player scores below the game.

## Updating our ScoreChannel

Let's make some changes to our `lib/platform_web/channels/score_channel.ex`
file. Instead of joining the default `"lobby"` topic, let's use the name of our
game as the topic to join. For the `join/3` fucntion, we'll set the first
argument to `"score:platformer"`.

```elixir
def join("score:platformer", payload, socket) do
  if authorized?(payload) do
    {:ok, socket}
  else
    {:error, %{reason: "unauthorized"}}
  end
end
```

Then, instead of manually coding the name of the game, we'll destructure the
slug by pattern matching with the `<>` string concatenation operator.

```elixir
def join("score:" <> game_slug, payload, socket) do
  if authorized?(payload) do
    {:ok, socket}
  else
    {:error, %{reason: "unauthorized"}}
  end
end
```

Then, let's go back to the `Platformer.elm` file and make the changes so we're
passing the game slug in the channel topic. There are three places we need to
make this change. First, we can update the name in the `initialSocket` and
`initialChannel` functions:

```elm
initialSocket : ( Phoenix.Socket.Socket Msg, Cmd (Phoenix.Socket.Msg Msg) )
initialSocket =
    let
        devSocketServer =
            "ws://localhost:4000/socket/websocket"
    in
        Phoenix.Socket.init devSocketServer
            |> Phoenix.Socket.withDebug
            |> Phoenix.Socket.on "shout" "score:platformer" SendScore
            |> Phoenix.Socket.join initialChannel


initialChannel : Phoenix.Channel.Channel msg
initialChannel =
    Phoenix.Channel.init "score:platformer"
```

Then, just update the `SendScoreRequest` case in our `update` function to use
our new `"score:platformer"` topic:

```elm
SendScoreRequest ->
    let
        payload =
            Encode.object [ ( "player_score", Encode.int model.playerScore ) ]

        phxPush =
            Phoenix.Push.init "shout" "score:platformer"
                |> Phoenix.Push.withPayload payload
                |> Phoenix.Push.onOk SendScore
                |> Phoenix.Push.onError SendScoreError

        ( phxSocket, phxCmd ) =
            Phoenix.Socket.push phxPush model.phxSocket
    in
        ( { model | phxSocket = phxSocket }
        , Cmd.map PhoenixMsg phxCmd
        )
```

Now, when we load the game in the browser, we should see that we're joining the
`"score:platformer"` topic:

```shell
Phoenix message: { event = "phx_reply", topic = "score:platformer", payload = { status = "ok", response = {} }, ref = Just 0 }
```

The reason this is important is that we need to know which game is being
played and the current player in order to save their score.

## Tracking Data Over the Socket

Let's make some additional changes to the `join/3` function we worked with in
the last section. We're going to learn how to assign values to the `socket`
that we can use to work with data in our channel.

Above the `join/3` function, let's add a couple of aliases for working with
our existing structures.

```elixir
alias Platform.Accounts
alias Platform.Products
```

Now, we can find the game that's currently being played, and assign the
`game_id` as a value we can work with in the socket. In our `join/3` function,
let's make the following changes:

```elixir
def join("score:" <> game_slug, payload, socket) do
  if authorized?(payload) do
    game = Products.get_game_by_slug!(game_slug)
    socket = assign(socket, :game_id, game.id)
    {:ok, socket}
  else
    {:error, %{reason: "unauthorized"}}
  end
end
```

The `Products.get_game_by_slug!/1` function is something we created in the
**Game Setup** chapter. We can use it here to find the game record, and then
find the `game.id`.

Then, we use the `assign(socket, :game_id, game.id)` syntax to assign that
value and make it accessible when working with our `socket`. In other words,
we'll be able to use `socket.assigns.game_id` to access this value in any of
our handle functions now. This will be useful in the next section.

## Handling a New Message

In addition to "shouting" the player scores over the socket, we also want to be
able to save the score to the database as a `Gameplay` record. In the
`lib/platform_web/channels/score_channel.ex` file, let's add another
`handle_in/3` function below the existing ones.

```elixir
def handle_in("save_score", %{"player_score" => player_score} = payload, socket) do
  broadcast(socket, "save_score", payload)
  {:noreply, socket}
end
```

Note that we're pattern matching the `player_score` from the `payload` so the
value is easily accessible inside our function.

Now, let's create our new `Gameplay` record from inside this function. We have
the `player_score` available in the `payload`, and the `game_id` is accessible
in the `socket`. We're going to hard-code the `player_id` value for now until
we find a way to track the current user in our channel.

```elixir
def handle_in("save_score", %{"player_score" => player_score} = payload, socket) do
  Products.create_gameplay(%{player_score: player_score, game_id: socket.assigns.game_id, player_id: 1)
  broadcast(socket, "save_score", payload)
  {:noreply, socket}
end
```

## Creating Gameplays

In order to get the channel feature above working, we need to create a new
function in the `lib/platform/products.ex` file. Right below the existing
`create_game/1` function, let's create a new function called
`create_gameplay/1`.

```elixir
def create_game(attrs \\ %{}) do
  %Game{}
  |> Game.changeset(attrs)
  |> Repo.insert()
end

def create_gameplay(attrs \\ %{}) do
  %Gameplay{}
  |> Gameplay.changeset(attrs)
  |> Repo.insert()
end
```

These functions are very similar. We need to pass a `game_id`, a `player_id`,
and a `player_score` to our new function to save a new record.
